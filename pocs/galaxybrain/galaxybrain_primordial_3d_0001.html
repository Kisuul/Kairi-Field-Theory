<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="PhaseCube Cosmology 3D – Ternary field with memory, parity, collapse, and interactive flux injection">
<meta name="keywords" content="ternary ca, cosmology simulation, plasma cosmology, emergence, kft">
<meta name="author" content="Christopher 'Kisuul' Lohman with Grok">

<title>PhaseCube Cosmology 3D – Primordial Field</title>

<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  html, body { height: 100%; background: #000; color: #fff; font-family: system-ui, -apple-system, sans-serif; overflow: hidden; }
  #app { height: 100%; display: grid; grid-template-rows: auto 1fr auto; }
  header, footer { padding: 0.75rem; text-align: center; background: rgba(0,0,0,0.6); backdrop-filter: blur(4px); }
  header h1 { font-size: 1.4rem; margin-bottom: 0.4rem; }
  main { position: relative; overflow: hidden; }
  #render-target { width: 100%; height: 100%; display: block; }
  #overlay {
    position: absolute; left: 1rem; top: 1rem; font-family: monospace; font-size: 13px;
    background: rgba(0,0,0,0.5); padding: 0.5rem 0.8rem; border-radius: 4px; pointer-events: none;
  }
  #help {
    position: absolute; right: 1rem; top: 1rem; font-family: monospace; font-size: 13px;
    background: rgba(0,0,0,0.5); padding: 0.5rem 0.8rem; border-radius: 4px; max-width: 300px;
  }
</style>
</head>
<body>
<div id="app">
  <header>
    <h1>PhaseCube Cosmology 3D – Primordial Field</h1>
    <div>W/S/A/D/Q/E: rotate • +/-: zoom • M: toggle mouse inject • Click: flip parity</div>
  </header>

  <main>
    <canvas id="render-target"></canvas>
    <div id="overlay"></div>
    <div id="help">
      Mouse drag: inject flux (when M toggled on)<br>
      Click anywhere: flip global parity<br>
      Collapse flash every ~240 frames
    </div>
  </main>

  <footer>
    <p>Christopher “Kisuul” Lohman with Grok ∴ Dec 19 2025</p>
  </footer>
</div>

<script type="module">
const app = {
  canvas: document.getElementById('render-target'),
  ctx: null,
  overlay: document.getElementById('overlay'),

  // Grid size – 32³ = 32768 cells – smooth and performant
  SIZE: 32,
  field: null,
  history: null,

  // Camera
  rotX: 0.3, rotY: 0.8,
  zoom: 1.0,
  minZoom: 0.4, maxZoom: 3.0,

  // Interaction
  parity: 0,
  mouseInject: true,
  mouse: { x: 0, y: 0, active: false },

  frame: 0,
  collapseInterval: 240,
  showCollapse: false,

  initRenderer() {
    this.ctx = this.canvas.getContext('2d');
    this.resize();
    window.addEventListener('resize', () => this.resize());

    // Mouse
    this.canvas.addEventListener('mousemove', e => {
      const r = this.canvas.getBoundingClientRect();
      this.mouse.x = (e.clientX - r.left) / r.width;
      this.mouse.y = (e.clientY - r.top) / r.height;
      this.mouse.active = true;
    });
    this.canvas.addEventListener('mouseleave', () => this.mouse.active = false);
    this.canvas.addEventListener('click', () => this.parity ^= 1);

    // Keyboard
    window.addEventListener('keydown', e => {
      switch(e.key.toLowerCase()) {
        case 'w': this.rotX -= 0.1; break;
        case 's': this.rotX += 0.1; break;
        case 'a': this.rotY -= 0.1; break;
        case 'd': this.rotY += 0.1; break;
        case 'q': this.rotY -= 0.2; break; // yaw left
        case 'e': this.rotY += 0.2; break; // yaw right
        case '=': case '+': this.zoom = Math.min(this.maxZoom, this.zoom + 0.1); break;
        case '-': this.zoom = Math.max(this.minZoom, this.zoom - 0.1); break;
        case 'm': this.mouseInject = !this.mouseInject; break;
      }
    });
  },

  resize() {
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    this.canvas.width = window.innerWidth * dpr;
    this.canvas.height = window.innerHeight * dpr;
    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  },

  initField() {
    const N = this.SIZE ** 3;
    this.field = new Int8Array(N);
    this.history = new Array(N);
    for (let i = 0; i < N; i++) {
      this.history[i] = [];
      if (Math.random() < 0.05) {
        this.field[i] = Math.random() < 0.5 ? -1 : 1;
      }
    }
  },

  idx(x, y, z) {
    return (x + this.SIZE) % this.SIZE +
           ((y + this.SIZE) % this.SIZE) * this.SIZE +
           ((z + this.SIZE) % this.SIZE) * this.SIZE * this.SIZE;
  },

  updateCell(x, y, z) {
    const i = this.idx(x, y, z);
    const me = this.field[i];

    let sum = 0, same = 0;
    for (let dz = -1; dz <= 1; dz++)
    for (let dy = -1; dy <= 1; dy++)
    for (let dx = -1; dx <= 1; dx++) {
      if (dx===0 && dy===0 && dz===0) continue;
      const v = this.field[this.idx(x+dx, y+dy, z+dz)];
      sum += v;
      if (v === me) same++;
    }

    const h = this.history[i];
    h.push(me);
    if (h.length > 5) h.shift();
    const uniformHistory = h.length === 5 && h.every(v => v === h[0]);

    let next = me;
    if (sum > 6) next = 1;
    else if (sum < -6) next = -1;
    else next = this.parity ? me : -me;

    if (same > 20 || uniformHistory) {
      this.parity ^= 1;
      next = -me;
    }

    this.field[i] = next;
  },

  injectFlux() {
    if (!this.mouseInject || !this.mouse.active) return;
    const mx = Math.floor(this.mouse.x * this.SIZE);
    const my = Math.floor(this.mouse.y * this.SIZE);
    const mz = Math.floor(this.SIZE / 2); // inject in central slice

    const r = 3;
    for (let dz = -r; dz <= r; dz++)
    for (let dy = -r; dy <= r; dy++)
    for (let dx = -r; dx <= r; dx++) {
      if (dx*dx + dy*dy + dz*dz > r*r) continue;
      const i = this.idx(mx+dx, my+dy, mz+dz);
      this.field[i] = this.parity ? 1 : -1;
    }
  },

  step() {
    // Sparse update – ~800 cells per frame for fluidity
    for (let i = 0; i < 800; i++) {
      const x = Math.floor(Math.random() * this.SIZE);
      const y = Math.floor(Math.random() * this.SIZE);
      const z = Math.floor(Math.random() * this.SIZE);
      this.updateCell(x, y, z);
    }
    this.injectFlux();

    this.frame++;
    if (this.frame % this.collapseInterval === 0) this.showCollapse = !this.showCollapse;
  },

  render() {
    const ctx = this.ctx;
    const w = this.canvas.clientWidth;
    const h = this.canvas.clientHeight;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, w, h);

    const points = [];
    const scale = 180 * this.zoom;
    const cx = w / 2, cy = h / 2;
    const crx = Math.cos(this.rotX), srx = Math.sin(this.rotX);
    const cry = Math.cos(this.rotY), sry = Math.sin(this.rotY);

    const half = (this.SIZE - 1) / 2;
    for (let z = 0; z < this.SIZE; z++)
    for (let y = 0; y < this.SIZE; y++)
    for (let x = 0; x < this.SIZE; x++) {
      const v = this.field[this.idx(x, y, z)];
      if (v === 0) continue;

      let px = (x - half) * scale;
      let py = (y - half) * scale;
      let pz = (z - half) * scale;

      // Rotate X
      let ty = py * crx - pz * srx;
      let tz = py * srx + pz * crx;
      py = ty; pz = tz;

      // Rotate Y
      let tx = px * cry + pz * sry;
      tz = -px * sry + pz * cry;
      px = tx; pz = tz;

      const depth = pz + 300;
      if (depth < 20) continue;

      const projX = cx + px / depth * 400;
      const projY = cy + py / depth * 400;
      const size = 3 + 8 * (300 / depth);

      points.push({ x: projX, y: projY, size, v, depth });
    }

    points.sort((a, b) => a.depth - b.depth);

    for (const p of points) {
      ctx.fillStyle = p.v > 0 ? '#4aa3ff' : '#ff5577';
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fill();
    }

    if (this.showCollapse) {
      ctx.globalAlpha = 0.2;
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, w, h);
      ctx.globalAlpha = 1;
    }

    this.overlay.innerHTML = `
      Parity: ${this.parity}<br>
      Frame: ${this.frame}<br>
      Zoom: ${this.zoom.toFixed(2)}<br>
      Mouse inject: ${this.mouseInject ? 'ON' : 'OFF'}<br>
      Collapse: ${this.showCollapse}
    `;
  },

  update() {
    this.step();
    this.render();
    requestAnimationFrame(() => this.update());
  },

  start() {
    this.initRenderer();
    this.initField();
    this.update();
  }
};

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => app.start());
} else {
  app.start();
}
</script>
</body>
</html>
