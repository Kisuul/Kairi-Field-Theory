<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Simulate a single agent 'swarm', aka GalaxyBrain">
    <meta name="keywords" content="AI, CA, POC">
    <meta name="author" content="Kisuul.luusik@gmail.com">
    
    <title>GalaxyBrain – PhaseCube Swarm Simulation - Single Agent</title>
    
    <!-- Minimal reset – narrow, deep, filamentary -->
    <style>
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        html, body {
            height: 100%;
            font-family: system-ui, -apple-system, sans-serif;
            line-height: 1.5;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        
        #app {
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-rows: auto 1fr auto;
        }
        
        header, footer {
            padding: 1rem;
            text-align: center;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
        }
        
        header h1 {
            font-size: 1.4rem;
            margin-bottom: 0.5rem;
        }
        
        main {
            position: relative;
        }
        
        #render-target {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .info {
            position: absolute;
            left: 12px;
            top: 12px;
            color: #ccc;
            font-family: monospace;
            font-size: 13px;
            pointer-events: none;
            background: rgba(0,0,0,0.4);
            padding: 8px 12px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="app">
        <header>
            <h1>GalaxyBrain – PhaseCube Swarm Simulation - Single Agent</h1>
            <div class="info">Click/tap to toggle parity • Drag to paint/nudge</div>
        </header>
        
        <main>
            <!-- Primary render surface – GalaxyBrain lives here -->
            <canvas id="render-target"></canvas>
        </main>
        
        <footer>
            <p>Universe in a Bottle from Kisuul the Chaos Gremlin, and Grok ∴ Dec 18 2025</p>
        </footer>
    </div>

    <script type="module">
        // Core app – everything replaceable from here
        const app = {
            canvas: document.getElementById('render-target'),
            gl: null,
            programs: {},
            textures: {},
            fbos: {},
            state: {
                parity: 0,
                impulse: { x: 0.5, y: 0.5, s: 0.0 },
                impulseDecay: 0.98
            },

            // TODO: Swap resolution here – 8192 works on desktop, drop to 4096/2048 for weaker GPUs
            BASE: 8192,
            W: 0, H: 0,

            initRenderer() {
                this.gl = this.canvas.getContext('webgl2', { antialias: false, alpha: false });
                if (!this.gl) {
                    alert('WebGL2 required');
                    return false;
                }

                this.resize();
                window.addEventListener('resize', () => this.resize());

                this.setupQuad();
                this.setupTextures();
                this.setupShaders();
                this.setupInteraction();

                return true;
            },

            resize() {
                const dpr = Math.min(window.devicePixelRatio || 1, 2);
                const cssW = Math.min(window.innerWidth, 1024);
                const cssH = window.innerHeight - 120; // leave room for header/footer

                this.canvas.style.width = cssW + 'px';
                this.canvas.style.height = cssH + 'px';

                this.W = this.BASE;
                this.H = this.BASE;

                this.canvas.width = Math.round(cssW * dpr);
                this.canvas.height = Math.round(cssH * dpr);

                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            },

            // --- Fullscreen quad (shared)
            setupQuad() {
                const gl = this.gl;
                const quadVS = `#version 300 es
                precision highp float;
                in vec2 aPos;
                out vec2 vUv;
                void main(){
                    vUv = aPos * 0.5 + 0.5;
                    gl_Position = vec4(aPos, 0.0, 1.0);
                }`;

                const verts = new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]);
                this.quadVAO = gl.createVertexArray();
                this.quadVBO = gl.createBuffer();
                gl.bindVertexArray(this.quadVAO);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadVBO);
                gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
            },

            bindQuadAttrib(program) {
                const gl = this.gl;
                gl.bindVertexArray(this.quadVAO);
                const loc = gl.getAttribLocation(program, 'aPos');
                gl.enableVertexAttribArray(loc);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadVBO);
                gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
            },

            // --- Ping-pong textures
            setupTextures() {
                const gl = this.gl;
                const W = this.W, H = this.H;

                const createTex = (data) => {
                    const t = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, t);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
                    return t;
                };

                const createFBO = (tex) => {
                    const fb = gl.createFramebuffer();
                    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                    return fb;
                };

                const initial = this.makeInitialBuffer();
                this.textures.a = createTex(initial);
                this.textures.b = createTex(null);
                this.fbos.a = createFBO(this.textures.a);
                this.fbos.b = createFBO(this.textures.b);

                this.srcTex = this.textures.a;
                this.dstFbo = this.fbos.b;
            },

            makeInitialBuffer() {
                const N = this.W * this.H * 4;
                const buf = new Uint8Array(N);
                for (let i = 0; i < this.W * this.H; i++) {
                    buf[i*4 + 0] = 128;     // neutral ternary
                    buf[i*4 + 1] = 0;        // age
                    buf[i*4 + 2] = 0;
                    buf[i*4 + 3] = 255;
                    if (Math.random() < 0.04) {
                        buf[i*4 + 0] = Math.random() < 0.5 ? 0 : 255;
                        buf[i*4 + 1] = 32;
                    }
                }
                return buf;
            },

            // --- Shaders (GalaxyBrain v1.0 extracted and reused entirely)
            setupShaders() {
                const gl = this.gl;

                const compile = (src, type) => {
                    const s = gl.createShader(type);
                    gl.shaderSource(s, src);
                    gl.compileShader(s);
                    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                        console.error(gl.getShaderInfoLog(s));
                        throw new Error('Shader compile failed');
                    }
                    return s;
                };

                const program = (vsSrc, fsSrc) => {
                    const p = gl.createProgram();
                    gl.attachShader(p, compile(vsSrc, gl.VERTEX_SHADER));
                    gl.attachShader(p, compile(fsSrc, gl.FRAGMENT_SHADER));
                    gl.linkProgram(p);
                    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
                        console.error(gl.getProgramInfoLog(p));
                        throw new Error('Program link failed');
                    }
                    return p;
                };

                const quadVS = `#version 300 es
                precision highp float;
                in vec2 aPos;
                out vec2 vUv;
                void main(){
                    vUv = aPos * 0.5 + 0.5;
                    gl_Position = vec4(aPos, 0.0, 1.0);
                }`;

                const updateFS = `#version 300 es
                precision highp float;
                precision highp sampler2D;
                in vec2 vUv;
                out vec4 outColor;
                uniform sampler2D uPrev;
                uniform vec2 uTexel;
                uniform vec3 uImpulse;
                uniform float uTime;
                uniform int uParity;

                int decodeState(float r) {
                    if (r > 0.66) return 1;
                    if (r < 0.33) return -1;
                    return 0;
                }
                float encodeState(int s) {
                    if (s == 1) return 1.0;
                    if (s == -1) return 0.0;
                    return 0.5;
                }

                void main(){
                    int sum = 0;
                    int me;
                    for(int oy=-1; oy<=1; oy++){
                        for(int ox=-1; ox<=1; ox++){
                            vec2 ofs = vUv + vec2(float(ox), float(oy)) * uTexel;
                            vec4 p = texture(uPrev, ofs);
                            int s = decodeState(p.r);
                            if (ox==0 && oy==0) { me = s; } else { sum += s; }
                        }
                    }
                    int tension = sum + me*3;

                    int next;
                    if (tension > 4) next = 1;
                    else if (tension < -4) next = -1;
                    else {
                        if (uParity == 1) next = me;
                        else next = -me;
                    }

                    vec4 cur = texture(uPrev, vUv);
                    float age = cur.g;

                    if (next == 0) age = 0.0;
                    else age = min(1.0, age + 0.012);

                    float imp = 0.0;
                    if (uImpulse.z > 0.001) {
                        float dx = vUv.x - uImpulse.x;
                        float dy = vUv.y - uImpulse.y;
                        float d2 = dx*dx + dy*dy;
                        float r = 0.02 + 0.04 * uImpulse.z;
                        float influence = exp(-d2/(r*r));
                        imp = influence * uImpulse.z * 0.6;
                        if (imp > 0.01) {
                            if (uParity == 1) next = 1;
                            else next = -1;
                            age = min(1.0, age + imp * 0.5);
                        }
                    }

                    float renc = encodeState(next);
                    outColor = vec4(renc, age, 0.0, 1.0);
                }`;

                const renderFS = `#version 300 es
                precision highp float;
                in vec2 vUv;
                out vec4 outColor;
                uniform sampler2D uTex;
                void main(){
                    vec4 p = texture(uTex, vUv);
                    float r = p.r; float age = p.g;
                    int s = (r > 0.66) ? 1 : (r < 0.33 ? -1 : 0);
                    vec3 col;
                    if (s == 1) col = vec3(0.18, 0.6, 1.0);
                    else if (s == -1) col = vec3(1.0, 0.38, 0.54);
                    else col = vec3(0.02, 0.01, 0.04);
                    float glow = 0.2 + 0.8 * age;
                    vec2 uv = vUv*2.0 - 1.0;
                    float vign = 1.0 - 0.6 * length(uv);
                    outColor = vec4(col * glow * vign, 1.0);
                }`;

                this.programs.update = program(quadVS, updateFS);
                this.programs.render = program(quadVS, renderFS);

                this.bindQuadAttrib(this.programs.update);
                this.bindQuadAttrib(this.programs.render);

                // Uniform locations
                this.uniforms = {
                    update: {
                        uPrev: gl.getUniformLocation(this.programs.update, 'uPrev'),
                        uTexel: gl.getUniformLocation(this.programs.update, 'uTexel'),
                        uImpulse: gl.getUniformLocation(this.programs.update, 'uImpulse'),
                        uTime: gl.getUniformLocation(this.programs.update, 'uTime'),
                        uParity: gl.getUniformLocation(this.programs.update, 'uParity'),
                    },
                    render: {
                        uTex: gl.getUniformLocation(this.programs.render, 'uTex'),
                    }
                };

                gl.useProgram(this.programs.update);
                gl.uniform2f(this.uniforms.update.uTexel, 1.0 / this.W, 1.0 / this.H);
            },

            setupInteraction() {
                const setImpulse = (e, toggleParity = false) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = (e.clientX || e.touches?.[0]?.clientX) - rect.left;
                    const y = (e.clientY || e.touches?.[0]?.clientY) - rect.top;
                    this.state.impulse.x = x / rect.width;
                    this.state.impulse.y = 1 - y / rect.height;
                    this.state.impulse.s = Math.min(1, this.state.impulse.s + 0.9);
                    if (toggleParity) this.state.parity ^= 1;
                };

                let down = false;
                this.canvas.addEventListener('pointerdown', e => { down = true; setImpulse(e, true); e.preventDefault(); });
                window.addEventListener('pointermove', e => { if (down) setImpulse(e); });
                window.addEventListener('pointerup', () => down = false);

                this.canvas.addEventListener('touchstart', e => { setImpulse(e, true); e.preventDefault(); }, {passive: false});
                this.canvas.addEventListener('touchmove', e => { setImpulse(e); e.preventDefault(); }, {passive: false});
            },

            // Main loop – narrow and deep
            update(t) {
                const gl = this.gl;

                // Update pass
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.dstFbo);
                gl.viewport(0, 0, this.W, this.H);
                gl.useProgram(this.programs.update);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.srcTex);
                gl.uniform1i(this.uniforms.update.uPrev, 0);
                gl.uniform1i(this.uniforms.update.uParity, this.state.parity);
                gl.uniform1f(this.uniforms.update.uTime, t * 0.001);
                gl.uniform3f(this.uniforms.update.uImpulse, this.state.impulse.x, this.state.impulse.y, this.state.impulse.s);
                gl.drawArrays(gl.TRIANGLES, 0, 6);

                // Ping-pong swap
                if (this.srcTex === this.textures.a) {
                    this.srcTex = this.textures.b;
                    this.dstFbo = this.fbos.a;
                } else {
                    this.srcTex = this.textures.a;
                    this.dstFbo = this.fbos.b;
                }

                // Render pass
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                gl.useProgram(this.programs.render);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.srcTex);
                gl.uniform1i(this.uniforms.render.uTex, 0);
                gl.drawArrays(gl.TRIANGLES, 0, 6);

                // Decay impulse
                this.state.impulse.s *= this.state.impulseDecay;
                if (this.state.impulse.s < 0.001) this.state.impulse.s = 0;

                requestAnimationFrame((t) => this.update(t));
            },

            start() {
                if (this.initRenderer()) {
                    requestAnimationFrame((t) => this.update(t));
                }
            }
        };

        // Launch
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => app.start());
        } else {
            app.start();
        }
    </script>
</body>
</html>
